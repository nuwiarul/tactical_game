// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: last_positions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLastPosition = `-- name: CreateLastPosition :one
INSERT INTO last_positions (operasi_id, skenario_id, marker_id, rot_x, rot_y, rot_z, pos_x, pos_y)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, operasi_id, skenario_id, marker_id, rot_x, rot_y, rot_z, pos_x, pos_y, created_at, updated_at
`

type CreateLastPositionParams struct {
	OperasiID  pgtype.UUID   `json:"operasi_id"`
	SkenarioID pgtype.UUID   `json:"skenario_id"`
	MarkerID   pgtype.UUID   `json:"marker_id"`
	RotX       pgtype.Float8 `json:"rot_x"`
	RotY       pgtype.Float8 `json:"rot_y"`
	RotZ       pgtype.Float8 `json:"rot_z"`
	PosX       pgtype.Float8 `json:"pos_x"`
	PosY       pgtype.Float8 `json:"pos_y"`
}

func (q *Queries) CreateLastPosition(ctx context.Context, arg CreateLastPositionParams) (LastPosition, error) {
	row := q.db.QueryRow(ctx, createLastPosition,
		arg.OperasiID,
		arg.SkenarioID,
		arg.MarkerID,
		arg.RotX,
		arg.RotY,
		arg.RotZ,
		arg.PosX,
		arg.PosY,
	)
	var i LastPosition
	err := row.Scan(
		&i.ID,
		&i.OperasiID,
		&i.SkenarioID,
		&i.MarkerID,
		&i.RotX,
		&i.RotY,
		&i.RotZ,
		&i.PosX,
		&i.PosY,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listLastPositonsByMarkerId = `-- name: ListLastPositonsByMarkerId :many
SELECT
    id, operasi_id, skenario_id, marker_id, rot_x, rot_y, rot_z, pos_x, pos_y,  created_at, updated_at
FROM
    last_positions
WHERE marker_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListLastPositonsByMarkerId(ctx context.Context, markerID pgtype.UUID) ([]LastPosition, error) {
	rows, err := q.db.Query(ctx, listLastPositonsByMarkerId, markerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LastPosition{}
	for rows.Next() {
		var i LastPosition
		if err := rows.Scan(
			&i.ID,
			&i.OperasiID,
			&i.SkenarioID,
			&i.MarkerID,
			&i.RotX,
			&i.RotY,
			&i.RotZ,
			&i.PosX,
			&i.PosY,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLastPositonsBySkenario = `-- name: ListLastPositonsBySkenario :many
SELECT
    id, operasi_id, skenario_id, marker_id, rot_x, rot_y, rot_z, pos_x, pos_y,  created_at, updated_at
FROM
    last_positions
WHERE skenario_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListLastPositonsBySkenario(ctx context.Context, skenarioID pgtype.UUID) ([]LastPosition, error) {
	rows, err := q.db.Query(ctx, listLastPositonsBySkenario, skenarioID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LastPosition{}
	for rows.Next() {
		var i LastPosition
		if err := rows.Scan(
			&i.ID,
			&i.OperasiID,
			&i.SkenarioID,
			&i.MarkerID,
			&i.RotX,
			&i.RotY,
			&i.RotZ,
			&i.PosX,
			&i.PosY,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLastPositionMove = `-- name: UpdateLastPositionMove :one
UPDATE last_positions
SET
    pos_x = $1,
    pos_y = $2,
    updated_at = NOW()
WHERE
    marker_id = $3
RETURNING id, operasi_id, skenario_id, marker_id, rot_x, rot_y, rot_z, pos_x, pos_y, created_at, updated_at
`

type UpdateLastPositionMoveParams struct {
	PosX     pgtype.Float8 `json:"pos_x"`
	PosY     pgtype.Float8 `json:"pos_y"`
	MarkerID pgtype.UUID   `json:"marker_id"`
}

func (q *Queries) UpdateLastPositionMove(ctx context.Context, arg UpdateLastPositionMoveParams) (LastPosition, error) {
	row := q.db.QueryRow(ctx, updateLastPositionMove, arg.PosX, arg.PosY, arg.MarkerID)
	var i LastPosition
	err := row.Scan(
		&i.ID,
		&i.OperasiID,
		&i.SkenarioID,
		&i.MarkerID,
		&i.RotX,
		&i.RotY,
		&i.RotZ,
		&i.PosX,
		&i.PosY,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLastPositionRot = `-- name: UpdateLastPositionRot :one
UPDATE last_positions
SET
    rot_x = $1,
    rot_y = $2,
    rot_z = $3,
    updated_at = NOW()
WHERE
    marker_id = $4
RETURNING id, operasi_id, skenario_id, marker_id, rot_x, rot_y, rot_z, pos_x, pos_y, created_at, updated_at
`

type UpdateLastPositionRotParams struct {
	RotX     pgtype.Float8 `json:"rot_x"`
	RotY     pgtype.Float8 `json:"rot_y"`
	RotZ     pgtype.Float8 `json:"rot_z"`
	MarkerID pgtype.UUID   `json:"marker_id"`
}

func (q *Queries) UpdateLastPositionRot(ctx context.Context, arg UpdateLastPositionRotParams) (LastPosition, error) {
	row := q.db.QueryRow(ctx, updateLastPositionRot,
		arg.RotX,
		arg.RotY,
		arg.RotZ,
		arg.MarkerID,
	)
	var i LastPosition
	err := row.Scan(
		&i.ID,
		&i.OperasiID,
		&i.SkenarioID,
		&i.MarkerID,
		&i.RotX,
		&i.RotY,
		&i.RotZ,
		&i.PosX,
		&i.PosY,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
