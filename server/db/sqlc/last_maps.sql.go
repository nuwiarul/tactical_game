// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: last_maps.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createLastMap = `-- name: CreateLastMap :one
INSERT INTO last_maps (operasi_id, skenario_id, center_x, center_y, zoom, pitch, bearing)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, operasi_id, skenario_id, center_x, center_y, zoom, bearing, pitch, created_at, updated_at
`

type CreateLastMapParams struct {
	OperasiID  pgtype.UUID   `json:"operasi_id"`
	SkenarioID pgtype.UUID   `json:"skenario_id"`
	CenterX    pgtype.Float8 `json:"center_x"`
	CenterY    pgtype.Float8 `json:"center_y"`
	Zoom       pgtype.Float8 `json:"zoom"`
	Pitch      pgtype.Float8 `json:"pitch"`
	Bearing    pgtype.Float8 `json:"bearing"`
}

func (q *Queries) CreateLastMap(ctx context.Context, arg CreateLastMapParams) (LastMap, error) {
	row := q.db.QueryRow(ctx, createLastMap,
		arg.OperasiID,
		arg.SkenarioID,
		arg.CenterX,
		arg.CenterY,
		arg.Zoom,
		arg.Pitch,
		arg.Bearing,
	)
	var i LastMap
	err := row.Scan(
		&i.ID,
		&i.OperasiID,
		&i.SkenarioID,
		&i.CenterX,
		&i.CenterY,
		&i.Zoom,
		&i.Bearing,
		&i.Pitch,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listLastMapsBySkenario = `-- name: ListLastMapsBySkenario :many
SELECT
    id, operasi_id, skenario_id, center_x, center_y, zoom, pitch, bearing,  created_at, updated_at
FROM
    last_maps
WHERE skenario_id = $1
ORDER BY created_at DESC
`

type ListLastMapsBySkenarioRow struct {
	ID         uuid.UUID        `json:"id"`
	OperasiID  pgtype.UUID      `json:"operasi_id"`
	SkenarioID pgtype.UUID      `json:"skenario_id"`
	CenterX    pgtype.Float8    `json:"center_x"`
	CenterY    pgtype.Float8    `json:"center_y"`
	Zoom       pgtype.Float8    `json:"zoom"`
	Pitch      pgtype.Float8    `json:"pitch"`
	Bearing    pgtype.Float8    `json:"bearing"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	UpdatedAt  pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) ListLastMapsBySkenario(ctx context.Context, skenarioID pgtype.UUID) ([]ListLastMapsBySkenarioRow, error) {
	rows, err := q.db.Query(ctx, listLastMapsBySkenario, skenarioID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLastMapsBySkenarioRow{}
	for rows.Next() {
		var i ListLastMapsBySkenarioRow
		if err := rows.Scan(
			&i.ID,
			&i.OperasiID,
			&i.SkenarioID,
			&i.CenterX,
			&i.CenterY,
			&i.Zoom,
			&i.Pitch,
			&i.Bearing,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLastMaps = `-- name: UpdateLastMaps :one
UPDATE last_maps
SET
    center_x = $1,
    center_y = $2,
    zoom = $3,
    pitch = $4,
    bearing = $5,
    updated_at = NOW()
WHERE
    skenario_id = $6
RETURNING id, operasi_id, skenario_id, center_x, center_y, zoom, bearing, pitch, created_at, updated_at
`

type UpdateLastMapsParams struct {
	CenterX    pgtype.Float8 `json:"center_x"`
	CenterY    pgtype.Float8 `json:"center_y"`
	Zoom       pgtype.Float8 `json:"zoom"`
	Pitch      pgtype.Float8 `json:"pitch"`
	Bearing    pgtype.Float8 `json:"bearing"`
	SkenarioID pgtype.UUID   `json:"skenario_id"`
}

func (q *Queries) UpdateLastMaps(ctx context.Context, arg UpdateLastMapsParams) (LastMap, error) {
	row := q.db.QueryRow(ctx, updateLastMaps,
		arg.CenterX,
		arg.CenterY,
		arg.Zoom,
		arg.Pitch,
		arg.Bearing,
		arg.SkenarioID,
	)
	var i LastMap
	err := row.Scan(
		&i.ID,
		&i.OperasiID,
		&i.SkenarioID,
		&i.CenterX,
		&i.CenterY,
		&i.Zoom,
		&i.Bearing,
		&i.Pitch,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
